---
id: tls
title: Transport Layer Security
sidebar_label: TLS
slug: /api/tls
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Masters and outstations may optionally use TLS which protects DNP3 communication by adding authentication and privacy. The library internally uses
[rustls](https://github.com/rustls/rustls), a modern TLS library written in safe Rust. It does **not** depend on OpenSSL or other system libraries, but will
interoperate seamlessly with other TLS implementations.

# Secure Authentication?

DNP3 SAv5 (and v2) contains a number of [design](https://www.cs.dartmouth.edu/~sergey/langsec/papers/crain-bratus-bolt-on-dnp3sa.pdf)
[flaws](https://cms-cdn.selinc.com/assets/Literature/Publications/Technical%20Papers/6910_AllAboutEve_CG_20190131_Web2.pdf?v=20191113-212654) and was never widely adopted.
The multi-user support in SAv5 has been [deprecated](https://rlc.vlinder.ca/blog/2019/10/26/tb2019-001-multi-user-sa) because it could never meet its stated design goals.
SAv6 aims to reduce the complexity of SAv5, but it has not been standardized yet and there are no full implementations.

:::tip
We recommend that DNP3 traffic be secured using TLS, and caution the industry to avoid home-grown solutions like secure authentication.
:::


## Supported Features

- TLS v1.2 and v1.3
- Supported cipher suites (in descending order of preference):
  - TLS v1.3:
    - `TLS_CHACHA20_POLY1305_SHA256`
    - `TLS_AES_256_GCM_SHA384`
    - `TLS_AES_128_GCM_SHA256`
  - TLS v1.2:
    - `TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256`
    - `TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256`
    - `TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384`
    - `TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256`
    - `TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384`
    - `TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256`
- Supported key exchange algorithms (in descending order of preference):
  - `x25519`
  - `secp384r1`
  - `secp256r1`
- Supported signature algorithms (in descending order of preference):
  - `ecdsa_secp384r1_sha384`
  - `ecdsa_secp256r1_sha256`
  - `ed25519` (v1.3 only)
  - `rsa_pss_sha512` (v1.3 only)
  - `rsa_pss_sha384` (v1.3 only)
  - `rsa_pss_sha256` (v1.3 only)
  - `rsa_pkcs1_sha512`
  - `rsa_pkcs1_sha384`
  - `rsa_pkcs1_sha256`
- Client and server name validation through the Common Name or Subject Alternative Name (SAN) extension.
- Self-signed certificates (with a special configuration).

## Configuration

TLS configuration is configured using the `TlsClientConfig` or `TlsServerConfig` structures. They are very similar and contain the following fields:

- `name`:
  * The client and the server both verify that the certificate presented by the peer is valid for this name. Check out the next section the gory details on
  name validation.
  * The client will advertise this name through a Server Name Indication (SNI) extension in the `Client Hello`.
- `peer_cert_path`:
  * Path to the unencrypted PEM file containing the trusted root certificate(s) or the peer self-signed certificate.
- `local_cert_path`:
  * Path to the unencrypted PEM file containing the certificate(s) to present to the peer.
- `private_key_path`:
  * Path to the PEM file containing the encrypted or plaintext private key corresponding to the public key in the presented certificate.
- `password`:
  * Password used to decrypt the private key file. This field should be left empty if the file is not encrypted. See the next section for more details.
- `min_tls_version`:
  * Minimum TLS version to support. Setting this to `Tls1_3` will force the usage of TLSv1.3.
- `certificate_mode`:
  * Mode of used to verify the peer certificate.

### Name validation

Name validation is always performed when `certificate_mode` is `TrustChain`, for
both the client and the server.

A valid name has the same requirements as a DNS name. This is defined in
[RFC 1034 Section 3.5](https://datatracker.ietf.org/doc/html/rfc1034#section-3.5),
updated by [RFC1123 Section 2.1](https://datatracker.ietf.org/doc/html/rfc1123#section-2),
with the additional exception that underscores `_` are allowed. A brief (but incomplete)
definition of a valid name would be the following:

- One or more labels separated by a single period
- Labels are made of alphanumeric characters `[A-Za-z0-9]`, hyphen `-` and underscores `_`
- A label cannot start or end with an hyphen `-`
- A label cannot be all numeric
- A label cannot be empty
- Maximum of 63 characters per label
- Maximum of 253 characters total

We first validate the name through the Subject Alternative Name (SAN) extension if it's present.
The SAN can contain multiple names and each name can contain a wildcard `*` character. The comparison
is case insensitive.

If and only if no SAN extension is present, then the Common Name from the certificate's Subject
is extracted and compared. The Common Name cannot contain a wildcard character and the comparison
is case sensitive. It is effectively compared byte-for-byte with the expected name.

:::note
Using SAN is the recommended way as Common Name usage is deprecated
and might be removed in the future. New certificates should provide name
in a SAN extension.
:::

### Private key encryption

Unencrypted private keys can be stored in PKCS#8 (`-----BEGIN PRIVATE KEY-----`) or
PKCS#1 format (`----BEGIN RSA PRIVATE KEY-----`).

Encrypted private keys **must** be stored in PKCS#8v2 (`-----BEGIN ENCRYPTED PRIVATE KEY-----`).
PKCS#1 encryption is **not** supported. The following algorithms are supported:

- Key derivation functions:
  - scrypt (RFC 7914) **recommended**
  - PBKDF2 (RFC 8018) SHA-2 based PRF with HMAC-SHA224, HMAC-SHA256, HMAC-SHA384, or HMAC-SHA512
- Symmetric encryption:
  - AES-128-CBC
  - AES-192-CBC
  - AES-256-CBC **recommended**

Notable unsupported algorithms are all SHA-1 based key derivation and DES/3DES symmetric encryption.
These are considered insecure and should not be used anymore.

[OpenSSL `pkcs8`](https://www.openssl.org/docs/man1.1.1/man1/openssl-pkcs8.html) tool can help you
encrypting or converting private keys.

:::warning
Encrypting private keys is not an automatic security guarantee. Proper access control should be prioritized
before encrypting the private the key. Keep in mind that encrypting a private key and leaving the password
somewhere not-so-private (e.g. in the source code of your application) is the equivalent of locking the doors
of your home and leaving a key in the mailbox.
:::

### Certificate mode

The `certificate_mode` parameter determines how the presented peer certificate
will be validated.

The default `TrustChain` value validates that the presented chain of certificates
and verify that the root certificate of the chain is one of those provided in
the `peer_cert_path` file. In the power industry, we recommend having a **single**
root certificate. It also validates that all critical extensions are handled, the
time validity, the DNS name and other details. It will **not** accept self-signed
certificate.

The `SelfSignedCertificate` value validates that only a single certificate is
presented and that it matches byte-for-byte the configured `peer_cert_path`. It
also checks the time validity using the system clock. Since the number of checks
is limited, a **thorough manual inspection of the configured self-signed certificate is
required beforehand**. Also note that the DNS name is **not** verified with this mode,
as this check should be performed manually before adding the self-signed certificate
to the configuration.

DNS name validation is not performed when `CertificateMode` is `SelfSignedCertificate`.

### Generating certificates

The following commands are provided as a guideline to generate certificates using the
OpenSSL command line interface.

#### CA trust chain

:::warning
You should probably use an actual CA software instead of manually generating these certificates.
These commands are provided for testing purposes.
:::

- Generate the root CA certificate: `openssl req -x509 -newkey rsa:4096 -keyout ./ca_key.pem -out ./ca_cert.pem -subj "/C=US/ST=Oregon/L=Bend/O=Test/CN=DO NOT USE" -nodes -days 3650`
- Generate the master CSR: `openssl req -new -newkey rsa:4096 -keyout ./master_key.pem -out ./master_csr.pem -subj "/C=US/ST=Oregon/L=Bend/O=Test/CN=DO NOT USE" -addext "subjectAltName=DNS:test.com" -nodes -days 365`
- Generate the master certificate: `openssl x509 -req -days 365 -in ./master_csr.pem -extfile <(printf "subjectAltName=DNS:test.com") -CA ./ca_cert.pem -CAkey ./ca_key.pem -set_serial 1 -out ./master_cert.pem -sha256`
- Generate the outstation CSR: `openssl req -new -newkey rsa:4096 -keyout ./outstation_key.pem -out ./outstation_csr.pem -subj "/C=US/ST=Oregon/L=Bend/O=Test/CN=DO NOT USE" -addext "subjectAltName=DNS:test.com" -nodes -days 365`
- Generate the outstation certificate: `openssl x509 -req -days 365 -in ./outstation_csr.pem -extfile <(printf "subjectAltName=DNS:test.com") -CA ./ca_cert.pem -CAkey ./ca_key.pem -set_serial 2 -out ./outstation_cert.pem -sha256`

#### Self-signed certificate

- Generate the master certificate: `openssl req -x509 -newkey rsa:4096 -keyout ./master_key.pem -out ./master_cert.pem -subj "/C=US/ST=Oregon/L=Bend/O=Test/CN=DO NOT USE" -addext "subjectAltName=DNS:test.com" -nodes -days 365`
- Generate the outstation certificate: `openssl req -x509 -newkey rsa:4096 -keyout ./outstation_key.pem -out ./outstation/entity2_cert.pem -subj "/C=US/ST=Oregon/L=Bend/O=Test/CN=DO NOT USE" -addext "subjectAltName=DNS:test.com" -nodes -days 365`
