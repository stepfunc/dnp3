---
id: tls
title: TLS
sidebar_label: TLS
slug: /api/tls
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Both TCP masters and outstations support TLS to enable authentication and privacy of the communication links. The library internally uses
[rustls](https://github.com/rustls/rustls), a modern TLS library entirely written in Rust. Therefore, it does **not** depend on OpenSSL
or other third-party library that needs to be present on the system, but will interoperate with peers using
these libraries.

## Supported features

- TLS v1.2 and v1.3
- Supported cipher suites (in descending order of preference):
  - TLS v1.3:
    - `TLS_CHACHA20_POLY1305_SHA256`
    - `TLS_AES_256_GCM_SHA384`
    - `TLS_AES_128_GCM_SHA256`
  - TLS v1.2:
    - `TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256`
    - `TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256`
    - `TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384`
    - `TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256`
    - `TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384`
    - `TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256`
- Supported key exchange groups (in descending order of preference):
  - `x25519`
  - `secp384r1`
  - `secp256r1`
- Supported signature hash algorithms (in descending order of preference):
  - `ecdsa_secp384r1_sha384`
  - `ecdsa_secp256r1_sha256`
  - `ed25519` (v1.3 only)
  - `rsa_pss_sha512` (v1.3 only)
  - `rsa_pss_sha384` (v1.3 only)
  - `rsa_pss_sha256` (v1.3 only)
  - `rsa_pkcs1_sha512`
  - `rsa_pkcs1_sha384`
  - `rsa_pkcs1_sha256`
- Client and server name validation through SAN and Common Name.
- Self-signed certificates (with a special configuration)

## Configuration

TLS configuration is done through the `TlsClientConfig` and `TlsServerConfig` structures. They are both very similar.
The fields are the following:

- `name`: name requested. The client will advertise this name through
  a Server Name Indication (SNI) extension in the `Client Hello`. Both
  the client and the server will verify that the presented certificate
  is valid for this DNS name. See the following section for more details
  about name validation. DNS name validation is not performed when
  `CertificateMode` is `SelfSignedCertificate`.
- `peer_cert_path`: path to the unencrypted PEM file containing the trusted
  root certificate(s) or the peer self-signed certificate.
- `local_cert_path`: path to the unencrypted PEM file containing the certificate
  or the chain of certificates to present to the peer.
- `private_key_path`: path to the unencrypted PEM file containing the private
  key of the local certificate.
- `password`: password used to decrypt the private key file. Leave empty if the file
  is not encrypted. See the next section for more details.
- `min_tls_version`: minimum TLS version to support. Setting this to `Tls1_3`
  will force TLSv1.3.
- `certificate_mode`: mode of verification of the presented certificate. See
  the next section for more details.

### Name validation

Name validation is always performed when `certificate_mode` is `TrustChain`, for
both the client and the server.

A valid name has the same requirements as a DNS name. This is defined in
[RFC 1034 Section 3.5](https://datatracker.ietf.org/doc/html/rfc1034#section-3.5),
updated by [RFC1123 Section 2.1](https://datatracker.ietf.org/doc/html/rfc1123#section-2),
with the additional exception that underscores `_` are allowed. A brief (but incomplete)
definition of a valid name would be the following:

- One or more labels separated by a single period
- Labels are made of alphanumeric characters `[A-Za-z0-9]`, hyphen `-` and underscores `_`
- A label cannot start or end with an hyphen `-`
- A label cannot be all numeric
- A label cannot be empty
- Maximum of 63 characters per label
- Maximum of 253 characters total

We first validate the name through the Subject Alternative Name (SAN) extension if it's present.
The SAN can contain multiple names and each name can contain a wildcard `*` character. The comparison
is case insensitive.

If and only if no SAN extension is present, then the Common Name from the certificate's Subject
is extracted and compared. The Common Name cannot contain a wildcard character and the comparison
is case sensitive. It is effectively compared byte-for-byte with the expected name.

:::note
Using SAN is the recommended way as Common Name usage is deprecated
and might be removed in the future. New certificates should provide name
in a SAN extension.
:::

### Private key encryption

Unencrypted private keys can be stored in PKCS#8 (`-----BEGIN PRIVATE KEY-----`) or
PKCS#1 format (`----BEGIN RSA PRIVATE KEY-----`).

Encrypted private keys **must** be stored in PKCS#8v2 (`-----BEGIN ENCRYPTED PRIVATE KEY-----`).
PKCS#1 encryption is **not** supported. The following algorithms are supported:

- Key derivation functions:
  - scrypt (RFC 7914) **recommended**
  - PBKDF2 (RFC 8018) SHA-2 based PRF with HMAC-SHA224, HMAC-SHA256, HMAC-SHA384, or HMAC-SHA512
- Symmetric encryption:
  - AES-128-CBC
  - AES-192-CBC
  - AES-256-CBC **recommended**

Notable unsupported algorithms are all SHA-1 based key derivation and DES/3DES symmetric encryption.
These are considered insecure and should not be used anymore.

[OpenSSL `pkcs8`](https://www.openssl.org/docs/man1.1.1/man1/openssl-pkcs8.html) tool can help you
encrypting or converting private keys.

:::warning
Encrypting private keys is not an automatic security guarantee. Proper access control should be prioritized
before encrypting the private the key. Keep in mind that encrypting a private key and leaving the password
somewhere not-so-private (e.g. in the source code of your application) is the equivalent of locking the doors
of your home and leaving a key in the mailbox.
:::

### Certificate mode

The `certificate_mode` parameter determines how the presented peer certificate
will be validated.

The default `TrustChain` value validates that the presented chain of certificates
and verify that the root certificate of the chain is one of those provided in
the `peer_cert_path` file. In the power industry, we recommend having a **single**
root certificate. It also validates that all critical extensions are handled, the
time validity, the DNS name and other details. It will **not** accept self-signed
certificate.

The `SelfSignedCertificate` value validates that only a single certificate is
presented and that it matches byte-for-byte the configured `peer_cert_path`. It
also checks the time validity using the system clock. Since the number of checks
is limited, a **thorough manual inspection of the configured self-signed certificate is
required beforehand**. Also note that the DNS name is **not** verified with this mode,
as this check should be performed manually before adding the self-signed certificate
to the configuration.

### Generating certificates

The following commands are provided as a guideline to generate certificates using the
OpenSSL command line interface.

#### CA trust chain

:::warning
You should probably use an actual CA software instead of manually generating these certificates.
These commands are provided for testing purposes.
:::

- Generate the root CA certificate: `openssl req -x509 -newkey rsa:4096 -keyout ./ca_key.pem -out ./ca_cert.pem -subj "/C=US/ST=Oregon/L=Bend/O=Test/CN=DO NOT USE" -nodes -days 3650`
- Generate the master CSR: `openssl req -new -newkey rsa:4096 -keyout ./master_key.pem -out ./master_csr.pem -subj "/C=US/ST=Oregon/L=Bend/O=Test/CN=DO NOT USE" -addext "subjectAltName=DNS:test.com" -nodes -days 365`
- Generate the master certificate: `openssl x509 -req -days 365 -in ./master_csr.pem -extfile <(printf "subjectAltName=DNS:test.com") -CA ./ca_cert.pem -CAkey ./ca_key.pem -set_serial 1 -out ./master_cert.pem -sha256`
- Generate the outstation CSR: `openssl req -new -newkey rsa:4096 -keyout ./outstation_key.pem -out ./outstation_csr.pem -subj "/C=US/ST=Oregon/L=Bend/O=Test/CN=DO NOT USE" -addext "subjectAltName=DNS:test.com" -nodes -days 365`
- Generate the outstation certificate: `openssl x509 -req -days 365 -in ./outstation_csr.pem -extfile <(printf "subjectAltName=DNS:test.com") -CA ./ca_cert.pem -CAkey ./ca_key.pem -set_serial 2 -out ./outstation_cert.pem -sha256`

#### Self-signed certificate

- Generate the master certificate: `openssl req -x509 -newkey rsa:4096 -keyout ./master_key.pem -out ./master_cert.pem -subj "/C=US/ST=Oregon/L=Bend/O=Test/CN=DO NOT USE" -addext "subjectAltName=DNS:test.com" -nodes -days 365`
- Generate the outstation certificate: `openssl req -x509 -newkey rsa:4096 -keyout ./outstation_key.pem -out ./outstation/entity2_cert.pem -subj "/C=US/ST=Oregon/L=Bend/O=Test/CN=DO NOT USE" -addext "subjectAltName=DNS:test.com" -nodes -days 365`
