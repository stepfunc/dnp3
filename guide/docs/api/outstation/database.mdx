---
id: database
title: Database
sidebar_label: Database
slug: /api/outstation/database
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Use the `Database` class to manipulate the measurement types that the outstation exposes to the master. Note: while it's called a "database", it's really just
a thread-safe data structure.

## Adding Points

You must initialize the points before the outstation exposes any measurement data. While you should do this when you create the outstation, you can add points to a running outstation as well. Except for Octet Strings that don't require conjuration, each measurement type has a unique configuration that accounts for:

* An event class assignment for the point
* Default static and event variations for the type
* Type-specific dead-bands that default to zero (Binary points have no deadband)

When you add a point, it will have the following default value with `RESTART` flags:

* Binary points set to `false`
* Numeric values set to `0`
* Octet Strings set to the value of `[0x00]`
* Double-bit Binary points set to `Indeterminate`

Update the value right after adding the point if you don't want a connecting master to see `RESTART`.

<Tabs
groupId="language"
defaultValue="Rust"
values={[
{label: 'Rust', value: 'Rust'},
{label: 'C', value: 'C'},
{label: 'Java', value: 'Java'},
{label: 'C#', value: 'C#'},
]}>
<TabItem value="Rust">

```rust
{{#include ../dnp3/examples/outstation_tcp_server.rs:database_init}}
```

</TabItem>
<TabItem value="C">

```c
// initialize 10 of every point type
{{#include ../ffi/bindings/c/outstation_example.c:database_init_transaction}}

// during program initialization - "outstation" already created
{{#include ../ffi/bindings/c/outstation_example.c:database_init}}
```

</TabItem>
<TabItem value="Java">

```java
// you can use a separate method or just initialize directly in the lambda expression
{{#include ../ffi/bindings/java/examples/src/main/java/io/stepfunc/dnp3/examples/OutstationExample.java:database_init_function}}

// during program initialization - "outstation" already created
{{#include ../ffi/bindings/java/examples/src/main/java/io/stepfunc/dnp3/examples/OutstationExample.java:database_init}}
```

</TabItem>
<TabItem value="C#">

```csharp
{{#include ../ffi/bindings/dotnet/examples/outstation/Program.cs:database_init}}
```

</TabItem>
</Tabs>

## Updating Points

You can update a point value in a new transaction or in the same transaction you use to create it. This is useful if the outstation
has local access to values at startup, such as via a local ADC.

The `UpdateOptions` struct lets you precisely control how a point update is processed. Use the default constructor to:

* Update the static value
* Produce an event if the point value changes in a way that exceeds the deadband or if the flags change

:::tip
Ignore event creation during startup initialization if you don't want to create events for the initial values.
:::

## Getting Point Values

Some applications may wish to use the `Database` as a cache of the most recent value. Each type has getter methods to extract the value if present.

:::note
Since the point may not be defined, the getter can fail. If you try to retrieve a point that doesn't exist using Java and C#, it will create an exception.
:::

## Removing Points

Most applications don't need to remove points, but the option is there in case you want to remove points from a running outstation. There is a type-specific function for removing every point type given its index.

:::note
Removing a point stops the outstation from reporting static data for that point. However, it does NOT remove any queued events for that point from
the event buffer. Those events will remain in the event buffer until they are reported and cleared by confirmation.
:::